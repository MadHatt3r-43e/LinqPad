<Query Kind="Statements" />

string [] cleanedTexts = 
{
@"1000033110 Page 0
A
C
D
A
B
C
D
8 7 6 5 4 3 2 1
8 7 6 5 4 3 2 1
SHEET 1 OF 2
P. POSHUSTA
5/12/2020GREGG BAILEY
5/12/2020
5/18/2020
SCHEM,TEX,HEATER,DOOR,LIGHT,ALARM,CNTCTR
1000033110 05
GREGG BAILEY
B
DRAWN BY DATE
ENGR/DSGNR DATE
CHECKED BY DATE
DESCRIPTION
SIZE PART NUMBER REV.
PROJECT SCALE
THIS DRAWING AND THE
INFORMATION CONTAINED
THEREON IS SUBMITTED
CONFIDENTIALLY AND IS THE
PROPERTY OF PURCELL
SYSTEMS. USE, REPRODUCTION,
OR DISCLOSURE OF THE CONTENT
OF THIS DRAWING OR ANY PORTION
THEREOF FOR ANY PURPOSE MUST
BE APPROVED IN WRITING BY
PURCELL SYSTEMS -- - : -
16125 E. Euclid
Spokane Valley, WA 99216
Ph: 509-755-0341
Fax: 509-755-0345
R
an EnerSys company
DATECHECKEDDESCRIPTIONECNREV.DRAWN
1007420 ADDED NOTE 3, FIXED WIRING OF LED LIGHT PP 10/19/2020GFB 03
1007438 REMOVED NOTE 3, ADDED INDIVIDUAL WIRE LABELS PP 11/13/2020GFB 04
GFB 05 1007457 FIXED P/N CALLOUTS FOR ITEM 4,5 PP 12/2/2020
NOTES: UNLESS OTHERWISE NOTED.
B
- +-+
BLKREDBLK RED PDU
(FRONT VIEW)
L1 L2 L3 L4
T1 T2 T3 T4
A1 A2
CONTACTOR
COM
NC NO BLK
RED BLK+-
LIGHT 
ASSEMBLY
RED
1. SEE PAGE 2 FOR INPUT TERMINAL BLOCK, SPD AND PDU POWER CONNECTIONS.
ALSO SEE PAGE 2 FOR HEATER CONNECTIONS.
RED
L1 L2 L3 L4
T1 T2 T3 T4
A1 A2
CONTACTOR
CONTACTOR A CONTACTOR B
OUTSIDE TEMP
INSIDE TEMP
HEATER
INSIDE FAN 1
INSIDE FAN 2
OUTSIDE FAN 2
OUTSIDE FAN 1
ALARM
POWER
CONTACTOR A
CONTACTOR B
DOOR SWITCH
LIGHT
7
8
9
10
11
12
7
8
9
10
11
12
6
5
4
3
2
1
6
5
4
3
2
1
25A
ON
OFF
1
0
1 6 12
25A BREAKER LOADED IN PDU POSITION 12
J13
J12
J19
J7
J6
J11
J10
J9
J8
J18
J17
J16
J15
J14
J4
J1
J3
J2
HEATER SNAP DISK
2
2
ITEM PART NUMBER DESCRIPTION
1 4000021252 CABLE,TEMP SNSR,100K,NTC,MICROFIT
2 4000019332 CABLE,TEMP SNSR,100K,NTC,MICROFIT,12L
3 4000022111 CABLE,HTR PWR,CONTROLLER-CONTACTOR,#12
4 4000021894 CABLE ASSY,FAN EXT,LONG,MINIFIT,MX150L
5 4000021895 CABLE ASSY,FAN EXT,SHORT,MINIFIT,MX150L
6 4000021435 ASSY,FAN,48V,225MM,RCI,TERM,MICROFIT
7 4000021893 CABLE,CONTACTOR CNTRL,SNAP DISK,CNTRLR
8 4000021722 CABLE,ASSY,SET,10AWG,RED,PDU TO CONT
9 4000020421 CABLE,ASSY,LIGHT,PWR,MIC FIT,22AWG
10 4000020418 CABLE,ASSY,DR SW,CONTRL,2X22AWG,MIC FIT
11 4000020539 CABLE,ASSY,2X22,CONTACTOR A COIL,J15
12 4000020416 CABLE,ASSY,2X22,CONTACTOR B COIL,J14
13 4000021723 CABLE,CNTRL PWR,MEGAFIT,FERRULES,12AWG
14 4000020419 CABLE,ASSY,ENV ALARM,2X22AWG,NC,MIC FIT
2
1
3
4
5
6
6
7
9
10
11
12
13
14
8
7    V-
8    V-
9    V-
10   V-
11   V-
12   V-
1    V-
2    V-
3    V-
A L1 V- A L2 V- A L3 V- A L4 V- B L1 V- B L2 V- B L3 V- B L4 V-
RED
RED
RED
RED
RED
RED
RED RED
BLACK" ,

@"1000033110 Page 1
A
C
D
A
B
C
D
8 7 6 5 4 3 2 1
8 7 6 5 4 3 2 1
SHEET 2 OF 2
P. POSHUSTA
5/12/2020GREGG BAILEY
5/12/2020
5/18/2020
SCHEM,TEX,HEATER,DOOR,LIGHT,ALARM,CNTCTR
1000033110 05
GREGG BAILEY
B
DRAWN BY DATE
ENGR/DSGNR DATE
CHECKED BY DATE
DESCRIPTION
SIZE PART NUMBER REV.
PROJECT SCALE
THIS DRAWING AND THE
INFORMATION CONTAINED
THEREON IS SUBMITTED
CONFIDENTIALLY AND IS THE
PROPERTY OF PURCELL
SYSTEMS. USE, REPRODUCTION,
OR DISCLOSURE OF THE CONTENT
OF THIS DRAWING OR ANY PORTION
THEREOF FOR ANY PURPOSE MUST
BE APPROVED IN WRITING BY
PURCELL SYSTEMS -- - : -
16125 E. Euclid
Spokane Valley, WA 99216
Ph: 509-755-0341
Fax: 509-755-0345
R
an EnerSys company
NOTES: UNLESS OTHERWISE NOTED.
B
SPD
V+V-
PDU
(REAR VIEW)
-
+
BLKRED
BLK
RED
GRN/YELBLK
1615 18 17
CUSTOMER
SUPPLIED
-48VDC 100A MAX
FACTORY LUGS ON
REAR TERMINALS
CUSTOMER LUGS ON
FRONT TERMINALS
L1 L2 L3 L4
T1 T2 T3 T4
A1 A2
CONTACTOR
ITEM PART NUMBER DESCRIPTION
15 4000019050 CABLE,ASSY,10AWG,BLK&RED,RING,SPD
16 4000019052 CABLE,ASSY,4AWG,BLK&RED,TB TO PDU
17 4000010919 CBL ASSY,GND,6AWG,1X1 HL,1X2 HL,.25 STUD
18 4000019055 CABLE,ASSY,18AWG,BLK,PDU ALARM
19 4000022112 CABLE,HTR PWR,CONTACTOR-HEATER,#12
3
77
19
19
DOOR HEATER
RED
BLK
BLK
REDBLK
SNAP DISK
TCO
BLK
RED
RED
RED"
};

void EEMiniBOM(ref List<Tuple<String, String, String, Int32>> eeBOM
            , String cleanText
            , String materialNumber
            , bool lookForQuantity = true
            )
{


    try
    {
        List<String> bomText = cleanText.Split(new[] { Environment.NewLine }, StringSplitOptions.None).ToList();
        String parsedMaterialNumberandRevision = bomText[2];

        // ITEM is Pattern1
        // PART is Pattern2
        int bomHeaderIndex = 0;  //= bomText.FindIndex(element => element.StartsWith("ITEM") || element.StartsWith("PART") );
        Int32 materialNumberLength = 10;

        for (int i = 0; i < bomText.Count; i++)
        {
            String cleanItem = bomText[i].Trim();
            if (cleanItem.StartsWith("ITEM") || cleanItem.StartsWith("PART") || cleanItem.StartsWith("NUMBER"))
            {
                bomHeaderIndex = i;
                break;
            }
        }
        // return if BOM Header not found
        if (bomHeaderIndex == 0)
        {
            return;
        }


        String bomHeaderLine = bomText[bomHeaderIndex];
		Console.WriteLine(bomHeaderLine);
        bool quantityPresentIndicator = false;
        if (lookForQuantity)
        {
            if (bomHeaderLine.Contains("QTY"))
            {
                quantityPresentIndicator = true;
            }
        }

		int minValidLineLength = 13;
        String headerOutput = String.Format("BOM Header line for {0}: {1}", materialNumber, bomHeaderLine);
        if (bomHeaderIndex > 0)
        {
            for (int i = bomHeaderIndex + 1; i < bomText.Count(); i++)
            {
                try
                {
                    String bomElement = bomText[i];

						
                    if (bomElement != String.Empty)
                    {
						// if the line doesn't have enough characters to be valid, skip the line
						char firstChar = bomElement.ToCharArray()[0];
						if(bomElement.Length <= minValidLineLength || ! Char.IsDigit(firstChar) )
							continue;
						
                        Int32 quantityOffset = 0;
                        if (quantityPresentIndicator)
                        {
                            quantityOffset = 2;
                        }

                        // Item
                        Int32 itemLength = 0;
                        Int32 itemInt = 0;
                        // item may be two columns, ie. 11
                        //String item = bomElement.Substring(0, 1);
                        String item = bomElement.Substring(0, 2).Trim();
                        bool foundIntItem = Int32.TryParse(item, out itemInt);
						
                        if (foundIntItem)
                        {
                            if(itemInt > 0 && itemInt < 10)
                            {
                                itemLength = 1;
                            }
                            else if (itemInt > 9 && itemInt < 100)
                            {
                                itemLength = 2;
                            }
                            else if (itemInt > 90 && itemInt < 1000)
                            {
                                itemLength = 3;
                            }
                        }
						else
                        {
                            String itemError = String.Format("Error finding item for {0}", bomElement);
                            Console.WriteLine(itemError);
                        }

                        // Material Number
                        String mNumber = String.Empty;
                        if (bomElement.Length >= materialNumberLength)
                        {
                            mNumber = bomElement.Substring(itemLength + 1, materialNumberLength);
                        }
                        else
                        {
                            Console.WriteLine("EEMiniBOM() misformedLine finding material number: " + mNumber + " for " + materialNumber + " bomElement: " + bomElement);
                        }
						
                        // Description
                        String description = String.Empty;
                        if (bomElement.Length >= itemLength + materialNumberLength + 1)
                        {
                            description = bomElement.Substring(itemLength + materialNumberLength + 1, bomElement.Length - (itemLength + materialNumberLength + 1) - quantityOffset);
                        }
                        else
                        {
                            Console.WriteLine("EEMiniBOM() misformedLine finding description: " + bomElement + " for " + materialNumber);
                        }
						
						Int32 quantity = -1;
                        // Quantity
						if(quantityPresentIndicator)
						{
	                        String strQuantity = bomElement.Substring(bomElement.Length - quantityOffset).Trim();
	                        bool foundInt = Int32.TryParse(strQuantity, out quantity);
	                        if (!foundInt)
	                        {
	                            String quantityError = "Error finding quantity for " + mNumber + " in " + materialNumber + ".  QTY Found " + strQuantity;
	                            Console.WriteLine(quantityError);
	                        }
						}
						
						if(foundIntItem)
						{
                        	eeBOM.Add(new Tuple<String, String, String, Int32>(item, mNumber, description, quantity));
						}
                    }
					else  // line is empty
					{
						continue;
					}
                }
                catch (Exception exRow)
                {
                    String rowError = String.Format("Error processing cleanText row for {0} bomText {1}", materialNumber, bomText[i]);
					Console.WriteLine(exRow.Message);
                    Console.WriteLine(rowError);    
                }
            }
        }
    }
    catch (Exception ex)
    {
        String cleanTextError = String.Format("error creating EEMiniBOM for {0} from cleanText {1}", materialNumber, cleanText, "EEBOMCompare");
        Console.WriteLine(cleanTextError);   
    }

}
		
		
// test harness for flipping around bomCollector with Linq
List<List<Tuple<String, String, String, Int32>>> bomCollector = new List<List<Tuple<String, String, String, Int32>>>();


// cleanedTexts == 2 pages from 1-33110 in string[]
foreach( string s in cleanedTexts)
{
	//Console.WriteLine(s);
	List<Tuple<String, String, String, Int32>> eBOM = new List<Tuple<String, String, String, Int32>>();
	EEMiniBOM(ref eBOM, s, "1000033110", true);
	bomCollector.Add(eBOM);
}
bomCollector.Dump();



// flatten list
var flatlistBomCollector = bomCollector.SelectMany(b => b)
    .ToList();
flatlistBomCollector.Dump("Combined Schematic Entries");

// searchable entries
var searchableEntries = bomCollector.SelectMany(b => b)
	.Where(c => c.Item2 == "4000021894")
    .ToList();
searchableEntries.Dump();

// select the inner list which contains the item
var innerList = from bom in bomCollector
				where bom.Any(m => m.Item2 == "4000021895")
				select bom;
				
innerList.Dump();


/*

var fp = orders.Select(o =>
            {
                o.products = o.products.Select(p =>
                {
                    p.manufacturers.RemoveAll(m => m.City != "Hartford");
                    return p;
                }).ToList();

                return o;
            });


var tmpResult =  from n in bomCollector
			where n.Item1 == "3"
			orderby n descending
			select n;
*/